// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: plans.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPlans = `-- name: CountPlans :one
SELECT COUNT(id)
FROM "subscription"."plans"
WHERE (
  (name = $1 OR $1 IS NULL) AND
  (price >= $2 OR $2 IS NULL) AND
  (price <= $3 OR $3 IS NULL) AND
  (interval = $4 OR $4 IS NULL) AND
  (description ILIKE '%' || $5 || '%' OR $5 IS NULL)
)
`

type CountPlansParams struct {
	Name        pgtype.Text
	PriceFrom   pgtype.Float8
	PriceTo     pgtype.Float8
	Interval    NullSubscriptionPlanIntervals
	Description pgtype.Text
}

func (q *Queries) CountPlans(ctx context.Context, arg CountPlansParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPlans,
		arg.Name,
		arg.PriceFrom,
		arg.PriceTo,
		arg.Interval,
		arg.Description,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPlan = `-- name: CreatePlan :one
INSERT INTO "subscription"."plans" (name, price, interval, description)
VALUES ($1, $2, $3, $4)
RETURNING id, name, price, interval, description
`

type CreatePlanParams struct {
	Name        string
	Price       float64
	Interval    SubscriptionPlanIntervals
	Description pgtype.Text
}

func (q *Queries) CreatePlan(ctx context.Context, arg CreatePlanParams) (SubscriptionPlan, error) {
	row := q.db.QueryRow(ctx, createPlan,
		arg.Name,
		arg.Price,
		arg.Interval,
		arg.Description,
	)
	var i SubscriptionPlan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Interval,
		&i.Description,
	)
	return i, err
}

const deletePlan = `-- name: DeletePlan :exec
DELETE FROM "subscription"."plans"
WHERE id = $1
`

func (q *Queries) DeletePlan(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deletePlan, id)
	return err
}

const getPlan = `-- name: GetPlan :one
SELECT id, name, price, interval, description
FROM "subscription"."plans"
WHERE id = $1
`

func (q *Queries) GetPlan(ctx context.Context, id string) (SubscriptionPlan, error) {
	row := q.db.QueryRow(ctx, getPlan, id)
	var i SubscriptionPlan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Interval,
		&i.Description,
	)
	return i, err
}

const listPlans = `-- name: ListPlans :many
SELECT id, name, price, interval, description
FROM "subscription"."plans"
WHERE (
  (name = $1 OR $1 IS NULL) AND
  (price >= $2 OR $2 IS NULL) AND
  (price <= $3 OR $3 IS NULL) AND
  (interval = $4 OR $4 IS NULL) AND
  (description ILIKE '%' || $5 || '%' OR $5 IS NULL)
)
ORDER BY $6 DESC
LIMIT $8
OFFSET $7
`

type ListPlansParams struct {
	Name        pgtype.Text
	PriceFrom   pgtype.Float8
	PriceTo     pgtype.Float8
	Interval    NullSubscriptionPlanIntervals
	Description pgtype.Text
	OrderBy     interface{}
	Offset      int32
	Limit       int32
}

func (q *Queries) ListPlans(ctx context.Context, arg ListPlansParams) ([]SubscriptionPlan, error) {
	rows, err := q.db.Query(ctx, listPlans,
		arg.Name,
		arg.PriceFrom,
		arg.PriceTo,
		arg.Interval,
		arg.Description,
		arg.OrderBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubscriptionPlan
	for rows.Next() {
		var i SubscriptionPlan
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.Interval,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlan = `-- name: UpdatePlan :one
UPDATE "subscription"."plans"
SET
  name = COALESCE($2, name),
  price = COALESCE($3, price),
  interval = COALESCE($4, interval),
  description = CASE WHEN $5::boolean THEN NULL ELSE COALESCE($6, description) END
WHERE id = $1
RETURNING id, name, price, interval, description
`

type UpdatePlanParams struct {
	ID              string
	Name            pgtype.Text
	Price           pgtype.Float8
	Interval        NullSubscriptionPlanIntervals
	NullDescription bool
	Description     pgtype.Text
}

func (q *Queries) UpdatePlan(ctx context.Context, arg UpdatePlanParams) (SubscriptionPlan, error) {
	row := q.db.QueryRow(ctx, updatePlan,
		arg.ID,
		arg.Name,
		arg.Price,
		arg.Interval,
		arg.NullDescription,
		arg.Description,
	)
	var i SubscriptionPlan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Interval,
		&i.Description,
	)
	return i, err
}
