// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: invoice.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countInvoices = `-- name: CountInvoices :one
SELECT COUNT(id)
FROM "subscription"."invoices"
WHERE (
  (subscription_id = $1 OR $1 IS NULL) AND
  (amount >= $2 OR $2 IS NULL) AND
  (amount <= $3 OR $3 IS NULL) AND
  (issued_at >= $4 OR $4 IS NULL) AND
  (issued_at <= $5 OR $5 IS NULL) AND
  (paid = $6 OR $6 IS NULL)
)
`

type CountInvoicesParams struct {
	SubscriptionID pgtype.Text
	AmountFrom     pgtype.Float8
	AmountTo       pgtype.Float8
	IssuedAtFrom   pgtype.Timestamptz
	IssuedAtTo     pgtype.Timestamptz
	Paid           pgtype.Bool
}

func (q *Queries) CountInvoices(ctx context.Context, arg CountInvoicesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countInvoices,
		arg.SubscriptionID,
		arg.AmountFrom,
		arg.AmountTo,
		arg.IssuedAtFrom,
		arg.IssuedAtTo,
		arg.Paid,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInvoice = `-- name: CreateInvoice :one
INSERT INTO "subscription"."invoices" (subscription_id, amount, issued_at, paid)
VALUES ($1, $2, $3, $4)
RETURNING id, subscription_id, amount, issued_at, paid
`

type CreateInvoiceParams struct {
	SubscriptionID string
	Amount         float64
	IssuedAt       pgtype.Timestamptz
	Paid           bool
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (SubscriptionInvoice, error) {
	row := q.db.QueryRow(ctx, createInvoice,
		arg.SubscriptionID,
		arg.Amount,
		arg.IssuedAt,
		arg.Paid,
	)
	var i SubscriptionInvoice
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.Amount,
		&i.IssuedAt,
		&i.Paid,
	)
	return i, err
}

const deleteInvoice = `-- name: DeleteInvoice :exec
DELETE FROM "subscription"."invoices"
WHERE id = $1
`

func (q *Queries) DeleteInvoice(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteInvoice, id)
	return err
}

const getInvoice = `-- name: GetInvoice :one
SELECT id, subscription_id, amount, issued_at, paid
FROM "subscription"."invoices"
WHERE id = $1
`

func (q *Queries) GetInvoice(ctx context.Context, id string) (SubscriptionInvoice, error) {
	row := q.db.QueryRow(ctx, getInvoice, id)
	var i SubscriptionInvoice
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.Amount,
		&i.IssuedAt,
		&i.Paid,
	)
	return i, err
}

const listInvoices = `-- name: ListInvoices :many
SELECT id, subscription_id, amount, issued_at, paid
FROM "subscription"."invoices"
WHERE (
  (subscription_id = $1 OR $1 IS NULL) AND
  (amount >= $2 OR $2 IS NULL) AND
  (amount <= $3 OR $3 IS NULL) AND
  (issued_at >= $4 OR $4 IS NULL) AND
  (issued_at <= $5 OR $5 IS NULL) AND
  (paid = $6 OR $6 IS NULL)
)
ORDER BY $7 DESC
LIMIT $9
OFFSET $8
`

type ListInvoicesParams struct {
	SubscriptionID pgtype.Text
	AmountFrom     pgtype.Float8
	AmountTo       pgtype.Float8
	IssuedAtFrom   pgtype.Timestamptz
	IssuedAtTo     pgtype.Timestamptz
	Paid           pgtype.Bool
	OrderBy        interface{}
	Offset         int32
	Limit          int32
}

func (q *Queries) ListInvoices(ctx context.Context, arg ListInvoicesParams) ([]SubscriptionInvoice, error) {
	rows, err := q.db.Query(ctx, listInvoices,
		arg.SubscriptionID,
		arg.AmountFrom,
		arg.AmountTo,
		arg.IssuedAtFrom,
		arg.IssuedAtTo,
		arg.Paid,
		arg.OrderBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubscriptionInvoice
	for rows.Next() {
		var i SubscriptionInvoice
		if err := rows.Scan(
			&i.ID,
			&i.SubscriptionID,
			&i.Amount,
			&i.IssuedAt,
			&i.Paid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvoice = `-- name: UpdateInvoice :one
UPDATE "subscription"."invoices"
SET
  subscription_id = COALESCE($2, subscription_id),
  amount = COALESCE($3, amount),
  issued_at = COALESCE($4, issued_at),
  paid = COALESCE($5, paid)
WHERE id = $1
RETURNING id, subscription_id, amount, issued_at, paid
`

type UpdateInvoiceParams struct {
	ID             string
	SubscriptionID pgtype.Text
	Amount         pgtype.Float8
	IssuedAt       pgtype.Timestamptz
	Paid           pgtype.Bool
}

func (q *Queries) UpdateInvoice(ctx context.Context, arg UpdateInvoiceParams) (SubscriptionInvoice, error) {
	row := q.db.QueryRow(ctx, updateInvoice,
		arg.ID,
		arg.SubscriptionID,
		arg.Amount,
		arg.IssuedAt,
		arg.Paid,
	)
	var i SubscriptionInvoice
	err := row.Scan(
		&i.ID,
		&i.SubscriptionID,
		&i.Amount,
		&i.IssuedAt,
		&i.Paid,
	)
	return i, err
}
