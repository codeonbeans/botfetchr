// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: account_telegrams.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAccountTelegrams = `-- name: CountAccountTelegrams :one
SELECT COUNT(id)
FROM "account"."telegrams"
WHERE (
  (telegram_id = $1 OR $1 IS NULL) AND
  (is_bot = $2 OR $2 IS NULL) AND
  (first_name = $3 OR $3 IS NULL) AND
  (last_name = $4 OR $4 IS NULL) AND
  (username = $5 OR $5 IS NULL) AND
  (language_code = $6 OR $6 IS NULL) AND
  (photo_url = $7 OR $7 IS NULL) AND
  (is_premium = $8 OR $8 IS NULL) AND
  (created_at >= $9 OR $9 IS NULL) AND
  (created_at <= $10 OR $10 IS NULL)
)
`

type CountAccountTelegramsParams struct {
	TelegramID    pgtype.Int8
	IsBot         pgtype.Bool
	FirstName     pgtype.Text
	LastName      pgtype.Text
	Username      pgtype.Text
	LanguageCode  pgtype.Text
	PhotoUrl      pgtype.Text
	IsPremium     pgtype.Bool
	CreatedAtFrom pgtype.Timestamptz
	CreatedAtTo   pgtype.Timestamptz
}

func (q *Queries) CountAccountTelegrams(ctx context.Context, arg CountAccountTelegramsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAccountTelegrams,
		arg.TelegramID,
		arg.IsBot,
		arg.FirstName,
		arg.LastName,
		arg.Username,
		arg.LanguageCode,
		arg.PhotoUrl,
		arg.IsPremium,
		arg.CreatedAtFrom,
		arg.CreatedAtTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAccountTelegram = `-- name: CreateAccountTelegram :one
INSERT INTO "account"."telegrams" (telegram_id, is_bot, first_name, last_name, username, language_code, photo_url, is_premium)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8
)
RETURNING id, telegram_id, is_bot, first_name, last_name, username, language_code, photo_url, is_premium, created_at
`

type CreateAccountTelegramParams struct {
	TelegramID   int64
	IsBot        bool
	FirstName    string
	LastName     string
	Username     pgtype.Text
	LanguageCode string
	PhotoUrl     pgtype.Text
	IsPremium    bool
}

func (q *Queries) CreateAccountTelegram(ctx context.Context, arg CreateAccountTelegramParams) (AccountTelegram, error) {
	row := q.db.QueryRow(ctx, createAccountTelegram,
		arg.TelegramID,
		arg.IsBot,
		arg.FirstName,
		arg.LastName,
		arg.Username,
		arg.LanguageCode,
		arg.PhotoUrl,
		arg.IsPremium,
	)
	var i AccountTelegram
	err := row.Scan(
		&i.ID,
		&i.TelegramID,
		&i.IsBot,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.LanguageCode,
		&i.PhotoUrl,
		&i.IsPremium,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAccountTelegram = `-- name: DeleteAccountTelegram :exec
DELETE FROM "account"."telegrams"
WHERE id = $1
`

func (q *Queries) DeleteAccountTelegram(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteAccountTelegram, id)
	return err
}

const getAccountTelegram = `-- name: GetAccountTelegram :one
SELECT id, telegram_id, is_bot, first_name, last_name, username, language_code, photo_url, is_premium, created_at
FROM "account"."telegrams"
WHERE id = $1
`

func (q *Queries) GetAccountTelegram(ctx context.Context, id int64) (AccountTelegram, error) {
	row := q.db.QueryRow(ctx, getAccountTelegram, id)
	var i AccountTelegram
	err := row.Scan(
		&i.ID,
		&i.TelegramID,
		&i.IsBot,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.LanguageCode,
		&i.PhotoUrl,
		&i.IsPremium,
		&i.CreatedAt,
	)
	return i, err
}

const listAccountTelegrams = `-- name: ListAccountTelegrams :many
SELECT id, telegram_id, is_bot, first_name, last_name, username, language_code, photo_url, is_premium, created_at
FROM "account"."telegrams"
WHERE (
  (telegram_id = $1 OR $1 IS NULL) AND
  (is_bot = $2 OR $2 IS NULL) AND
  (first_name = $3 OR $3 IS NULL) AND
  (last_name = $4 OR $4 IS NULL) AND
  (username = $5 OR $5 IS NULL) AND
  (language_code = $6 OR $6 IS NULL) AND
  (photo_url = $7 OR $7 IS NULL) AND
  (is_premium = $8 OR $8 IS NULL) AND
  (created_at >= $9 OR $9 IS NULL) AND
  (created_at <= $10 OR $10 IS NULL)
)
ORDER BY
  CASE WHEN $11::text = 'id_asc' THEN id END ASC,
  CASE WHEN $11 = 'id_desc' THEN id END DESC,
  CASE WHEN $11 = 'telegram_id_asc' THEN telegram_id END ASC,
  CASE WHEN $11 = 'telegram_id_desc' THEN telegram_id END DESC,
  CASE WHEN $11 = 'created_at_asc' THEN created_at END ASC,
  CASE WHEN $11 = 'created_at_desc' THEN created_at END DESC,
  created_at DESC
LIMIT $13
OFFSET $12
`

type ListAccountTelegramsParams struct {
	TelegramID    pgtype.Int8
	IsBot         pgtype.Bool
	FirstName     pgtype.Text
	LastName      pgtype.Text
	Username      pgtype.Text
	LanguageCode  pgtype.Text
	PhotoUrl      pgtype.Text
	IsPremium     pgtype.Bool
	CreatedAtFrom pgtype.Timestamptz
	CreatedAtTo   pgtype.Timestamptz
	OrderBy       string
	Offset        int32
	Limit         int32
}

func (q *Queries) ListAccountTelegrams(ctx context.Context, arg ListAccountTelegramsParams) ([]AccountTelegram, error) {
	rows, err := q.db.Query(ctx, listAccountTelegrams,
		arg.TelegramID,
		arg.IsBot,
		arg.FirstName,
		arg.LastName,
		arg.Username,
		arg.LanguageCode,
		arg.PhotoUrl,
		arg.IsPremium,
		arg.CreatedAtFrom,
		arg.CreatedAtTo,
		arg.OrderBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountTelegram
	for rows.Next() {
		var i AccountTelegram
		if err := rows.Scan(
			&i.ID,
			&i.TelegramID,
			&i.IsBot,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.LanguageCode,
			&i.PhotoUrl,
			&i.IsPremium,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccountTelegram = `-- name: UpdateAccountTelegram :one
UPDATE "account"."telegrams"
SET
  telegram_id = COALESCE($2, telegram_id),
  is_bot = COALESCE($3, is_bot),
  first_name = COALESCE($4, first_name),
  last_name = COALESCE($5, last_name),
  username = CASE WHEN $6::boolean THEN NULL ELSE COALESCE($7, username) END,
  language_code = COALESCE($8, language_code),
  photo_url = CASE WHEN $9::boolean THEN NULL ELSE COALESCE($10, photo_url) END,
  is_premium = COALESCE($11, is_premium),
  created_at = COALESCE($12, created_at)
WHERE id = $1
RETURNING id, telegram_id, is_bot, first_name, last_name, username, language_code, photo_url, is_premium, created_at
`

type UpdateAccountTelegramParams struct {
	ID           int64
	TelegramID   pgtype.Int8
	IsBot        pgtype.Bool
	FirstName    pgtype.Text
	LastName     pgtype.Text
	NullUsername bool
	Username     pgtype.Text
	LanguageCode pgtype.Text
	NullPhotoUrl bool
	PhotoUrl     pgtype.Text
	IsPremium    pgtype.Bool
	CreatedAt    pgtype.Timestamptz
}

func (q *Queries) UpdateAccountTelegram(ctx context.Context, arg UpdateAccountTelegramParams) (AccountTelegram, error) {
	row := q.db.QueryRow(ctx, updateAccountTelegram,
		arg.ID,
		arg.TelegramID,
		arg.IsBot,
		arg.FirstName,
		arg.LastName,
		arg.NullUsername,
		arg.Username,
		arg.LanguageCode,
		arg.NullPhotoUrl,
		arg.PhotoUrl,
		arg.IsPremium,
		arg.CreatedAt,
	)
	var i AccountTelegram
	err := row.Scan(
		&i.ID,
		&i.TelegramID,
		&i.IsBot,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.LanguageCode,
		&i.PhotoUrl,
		&i.IsPremium,
		&i.CreatedAt,
	)
	return i, err
}
